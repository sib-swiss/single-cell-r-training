## Learning outcomes

## **After having completed this chapter you will be able to:**
  
## - Load single cell data into R
## - Explain the basic structure of a `Seurat` object and extract count data and metadata
## - Calculate and visualize quality measures based on:
## - mitochondrial genes
## - ribosomal genes
## - hemoglobin genes
## - relative gene expression
## - Interpret the above quality measures per cell.
## - Perform cell filtering based on quality thresholds

# Material
## Exercises

### Loading scRNAseq data

## The next step after the generation of the count matrices with `cellranger count`, is the data analysis. The `R` package `Seurat` is currently the most popular software to do this. To start working with `Seurat` you can load it into your environment like this:
  
library(Seurat)

## You could type and copy-paste the commands of these exercises directly in the console. However, that makes it hard to track what you have done. In addition, it can be nice to add comments to your code, so you can read back why you have made certain choices. In order to do that, do not write commands in the console, but write them in a script, and send them to the console with <kbd>^ Ctrl + ⏎ Enter</kbd> (Windows) or <kbd>⌘ Command + ⏎ Enter</kbd> (MacOS).
## First, we will load a file specifying the different samples, and create an object specifying the location of the count data:
  

sample_info <- read.csv("course_data/sample_info_course.csv")
datadirs <- file.path("course_data", "count_matrices", sample_info$SampleName,
                      "outs", "filtered_feature_bc_matrix")
names(datadirs) <- gsub("_", "-", sample_info$SampleName)
datadirs <- datadirs[1:3]


## The object `datadirs` is a named vector specifying the paths of the count directories for each sample:

datadirs


## To run through a typical `Seurat` analysis, we will use the files that are in the directory `data/filtered_feature_bc_matrix`. This directory is part of the output generated by [`cellranger`](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger). To load this data into R and generate a sparse matrix, run the following command:
  

sparse_matrix <- Seurat::Read10X(data.dir = datadirs)


## This imports a raw count matrix. Have a look at the counts of the first 30 cells of three genes by running:
  

sparse_matrix[c("PECAM1", "CD8A", "TSPAN1"), 1:30]


## You will see many dots (zeros) and a few integers representing the counts per gene per cell. 

## To generate a `Seurat` object, we will run `CreateSeuratObject`. Note that while creating the object, we already do some mild filtering; we only import genes that are expressed in at least 3 cells, and we only import cells that have at least 100 different genes expressed:
  

seu <- Seurat::CreateSeuratObject(counts = sparse_matrix,
                                  project = "pbmmc",
                                  min.cells = 3,
                                  min.features = 100)


hist(seu$nCount_RNA)

hist(seu@meta.data$nCount_RNA)

## There are also built-in functions to plot data from `Seurat` object, for example `FeatureScatter`. This function enables you easily draw a scatterplot from a `Seurat` object:
  

Seurat::FeatureScatter(seu, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")


##  You can find a nice overview of such functions [here](https://satijalab.org/seurat/articles/essential_commands.html). 


### Visualizing QC per cell and gene

## While generating the `Seurat` object, there were already some quality measures calculated for each cell, namely the total UMI counts per cell (`nCount_RNA`) and the total number of detected features per cell (`nFeature_RNA`). We can plot those in a violin plot and evaluate their distribution per sample:
  

Seurat::VlnPlot(seu, features = c("nCount_RNA",
                                  "nFeature_RNA"))


## You can see that there is quite a wide range for both. A cell with low number of detected features or counts might not give you a lot of information, while a high number of detected features/counts might point to doublets.

## Single cells have often undergone sampling and/or dissociation and/or sorting. Therefore, there are often cells and genes in your dataset that cause variation due to technical reasons. In the following steps, we will visualize those and make decisions on whether or not to remove cells or genes with extreme values.

## We will start with calculating the percentage of counts coming from transcript types:
  
## - **Mitochondrial genes**: If a cell membrane is damaged, it looses free RNA quicker compared to mitochondrial RNA, because the latter is part of the mitochondrion. A high relative amount of mitochondrial counts can therefore point to damaged cells ([Lun et al. 2016](https://f1000research.com/articles/5-2122)). 
## - **Ribosomal genes**: Are not rRNA (ribosomal RNA) but is mRNA that code for ribosomal proteins. They do not point to specific issues, but it can be good to have a look at their relative abundance. They can have biological relevance (e.g. [Caron et al. 2020](https://www.nature.com/articles/s41598-020-64929-x)).
## - **Hemoglobin genes**: these transcripts are very abundant in erythrocytes. Depending on your application, you can expect 'contamination' of erythrocytes and select against it. 

## In order to have an idea about the relative counts of these type of genes in our dataset, we can calculate their expression as relative counts in each cell. We do that by selecting genes based on patterns (e.g. `^MT-` matches with all gene names starting with `MT`, i.e. mitochondrial genes):
  

# mitochondrial genes
seu <- Seurat::PercentageFeatureSet(seu, 
                                    pattern = "^MT-", 
                                    col.name = "percent.mito")

# ribosomal genes
seu <- Seurat::PercentageFeatureSet(seu, 
                                    pattern = "^RP[SL]",
                                    col.name = "percent.ribo")

# hemoglobin genes (but not HBP)
seu <- Seurat::PercentageFeatureSet(seu,
                                    pattern = "^HB[^(P)]",
                                    col.name = "percent.globin")



##   Now we can plot the distribution of these percentages in a violin plot:
  

Seurat::VlnPlot(seu, features = c("percent.mito",
                                  "percent.ribo",
                                  "percent.globin"))


## You can see that `PBMMC-2` is quite different from the two others, it has a group of cells with very low ribosomal counts and one with very high globin counts. Maybe these two percentages are negatively correlated? Let's have a look, by plotting the two percentages against each other:

Seurat::FeatureScatter(seu, 
                       feature1 = "percent.globin", 
                       feature2 = "percent.ribo")



library(ggplot2)
library(Matrix)
library(Seurat)

most_expressed_boxplot <- function(object, ngenes = 20){
  
  # matrix of raw counts
  cts <- Seurat::GetAssayData(object, assay = "RNA", layer = "counts")
  
  # get percentage/cell
  cts <- t(cts)/colSums(cts)*100
  medians <- SparseArray::colMedians(cts)
  
  # get top n genes
  most_expressed <- order(medians, decreasing = T)[ngenes:1]
  most_exp_matrix <- as.matrix((cts[,most_expressed]))
  
  # prepare for plotting
  most_exp_df <- stack(as.data.frame(most_exp_matrix))
  colnames(most_exp_df) <- c("perc_total", "gene")
  
  # boxplot with ggplot2
  boxplot <- ggplot(most_exp_df, aes(x=gene, y=perc_total)) +
    geom_boxplot() +
    coord_flip()
  return(boxplot)
}

most_expressed_boxplot(seu, 20)


## As for most 10X based poly-A enriched single cell datasets, we find a relatively high expression of MALAT1. Many researchers choose to remove it, but it can have biological relevance (e.g. [Shaat et al. 2021](https://www.nature.com/articles/s41420-020-00383-y)). 

### Cell filtering

## Based on the QC process we went through we can come to the following conclusions:

## - There are no cells with very high mitochondrial gene counts.
## - There are some cells with a hemoglobin and low ribosomal counts, and these are probably erythrocytes.
## - There are some cells with a very low and very high number of features. These might point to non-informative cells and doublets respectively. 
## - The 'usual suspect' MALAT1 sometimes makes up a large part of the counts per cell. As we do not see any other suggestions of dying/stressed cells, we leave it in. 

## In this case, a sensible decision would be to do mild filtering on the number of features per cell and mitochondrial counts. We can leave the possible erythrocytes in for now, and see where they end up later during the dimensionality reduction. 

## In the M&M of the [publication](https://www.nature.com/articles/s41598-020-64929-x#Sec7), the authors describe that they have used a threshold of < 8% mitochondrial counts and > 200 features per cell. To filter against possible doublets, here, we also filter out cells with > 5000 detected features/cell. Filtering `Seurat` objects can be done with the `subset` method for class `SeuratObject`:

seu <- subset(seu, subset = nFeature_RNA > 200 & 
                nFeature_RNA < 5000 &
                percent.mito < 8)


## To evaluate this did the trick we can visualize those parameters again in a violin plot:

Seurat::VlnPlot(seu, features = c("nFeature_RNA",
                                  "percent.mito"))


saveRDS(seu, "day1/seu_day1-2.rds")