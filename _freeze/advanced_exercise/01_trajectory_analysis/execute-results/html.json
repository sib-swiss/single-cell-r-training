{
  "hash": "fb91d644231411930488c7c209af1fcf",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Trajectory analysis\"\nexecute:\n  eval: false\n---\n\n\n\n\n\n## Material\n\nLecture Alex Russel Lederer:\n\n\n\n\n{{< downloadthis ../assets/pdf/Lecture_pseudotime_velocity.pdf dname=\"Lecture_pseudotime_velocity\" label=\"Download the presentation\" icon=\"filetype-pdf\" >}}\n\n\n\n\n\n\nLecture Tania Wyss and Rachel Marcone:\n\n\n\n\n{{< downloadthis ../assets/pdf/Trajectories.pdf dname=\"Trajectories\" label=\"Download the presentation\" icon=\"filetype-pdf\" >}}\n\n\n{{< video https://youtu.be/FNrjzFUMOzU?si=G-ETBiHkkMe6eWfQ >}}\n\n\n\n\n\n\n- `slingshot` [vignette](https://www.bioconductor.org/packages/release/bioc/vignettes/slingshot/inst/doc/vignette.html)\n- [`monocle3`](https://cole-trapnell-lab.github.io/monocle3/)\n\n## Exercises\n\nLoad the following packages:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(SingleCellExperiment)\nlibrary(scater)\nlibrary(slingshot)\nlibrary(ggplot2)\nlibrary(ggbeeswarm)\nlibrary(Seurat)\n```\n:::\n\n\n\n\n### Trajectory analysis using Slingshot\n\n> This part uses the `Deng` dataset\n\nFirst, download the dataset from github within your  **Terminal** tab as on Day 1:\n\n<figure>\n<img src=\"../assets/images/select_terminal_tab.png\" width=\"300\"/>\n</figure>\n\n\nType the following commands within the Terminal tab:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd course_data/\nwget https://github.com/hemberg-lab/nrg-paper-figures/raw/master/deng-reads.rds\n```\n:::\n\n\n\n\nThen, within R, import the rds file. the 'Deng' dataset is an object of class `SingleCellExperiment`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeng_SCE <- readRDS(\"course_data/deng-reads.rds\")\n```\n:::\n\n\n\n\nPerform the first steps of the analysis. The deng_SCE object contains cells that were isolated at different stages of mouse embryogenesis, from the zygote stage to the late blastula.\n\nThe levels of the cell type are in alphabetical order. We now change the level order for plotting in developmental order:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeng_SCE$cell_type2 <- factor(deng_SCE$cell_type2,\n                              levels = c(\"zy\",\n                                         \"early2cell\",\n                                         \"mid2cell\",\n                                         \"late2cell\",\n                                         \"4cell\",\n                                         \"8cell\",\n                                         \"16cell\",\n                                         \"earlyblast\",\n                                         \"midblast\",\n                                         \"lateblast\"))\n```\n:::\n\n\n\n\nWe can run a PCA directly on the object of class `SingleCellExperiment` with the function `runPCA`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeng_SCE <- scater::runPCA(deng_SCE, ncomponents = 50)\n```\n:::\n\n\n\n\nUse the `reducedDim` function to access the PCA and store the results.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npca <- SingleCellExperiment::reducedDim(deng_SCE, \"PCA\")\n```\n:::\n\n\n\n\nDescribe how the PCA is stored in a matrix. Why does it have this structure?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(pca)\n```\n:::\n\n\n\n\nAdd PCA data to the deng_SCE object.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeng_SCE$PC1 <- pca[, 1]\ndeng_SCE$PC2 <- pca[, 2]\n```\n:::\n\n\n\n\nPlot PC biplot with cells colored by cell_type2.\n`colData(deng_SCE)` accesses the cell metadata `DataFrame` object for `deng_SCE`.\nLook at Figure 1A of the [paper](https://science.sciencemag.org/content/343/6167/193) as a comparison to your PC biplot.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(as.data.frame(colData(deng_SCE)), aes(x = PC1, y = PC2, color = cell_type2)) +\n  geom_point(size=2, shape=20) +\n  theme_classic() +\n  xlab(\"PC1\") + ylab(\"PC2\") + ggtitle(\"PC biplot\")\n```\n:::\n\n\n\n\nPCA is a simple approach and can be good to compare to more complex algorithms\ndesigned to capture differentiation processes. As a simple measure of pseudotime\nwe can use the coordinates of PC1.\nPlot PC1 vs cell_type2.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeng_SCE$pseudotime_PC1 <- rank(deng_SCE$PC1)  # rank cells by their PC1 score\n```\n:::\n\n\n\n\nCreate a jitter plot\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(as.data.frame(colData(deng_SCE)), aes(x = pseudotime_PC1, y = cell_type2,\n                                             colour = cell_type2)) +\n  ggbeeswarm::geom_quasirandom(groupOnX = FALSE) +\n  theme_classic() +\n  xlab(\"PC1\") + ylab(\"Timepoint\") +\n  ggtitle(\"Cells ordered by first principal component\")\n```\n:::\n\n\n\n\nRead the Slingshot documentation (`?slingshot::slingshot`) and then run Slingshot below.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- slingshot::slingshot(deng_SCE, reducedDim = 'PCA')\n```\n:::\n\n\n\n\n::: {.callout-important}\n## Exercise\nGiven your understanding of the algorithm and the documentation, what is one\nmajor set of parameters we omitted here when running Slingshot?\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\nWe didn't set the parameter `clusterLabels`\n:::\n\nHere is a custom function to plot the PCA based on a `slingshot` object. Run it in the console to add it to your global environment:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCAplot_slingshot <- function(sce, draw_lines = TRUE, variable = NULL, legend = FALSE, ...){\n  # set palette for factorial variables\n  palf <- colorRampPalette(RColorBrewer::brewer.pal(8, \"Set2\"))\n  # set palette for numeric variables\n  paln <- colorRampPalette(RColorBrewer::brewer.pal(9, \"Blues\"))\n  # extract pca from SingleCellExperiment object\n  pca <- SingleCellExperiment::reducedDims(sce)$PCA\n  \n  if(is.null(variable)){\n    col <- \"black\"\n  }\n  if(is.character(variable)){\n    variable <- as.factor(variable)\n  }\n  if(is.factor(variable)){\n    colpal <- palf(length(levels(variable)))\n    colors <- colpal[variable]\n  }\n  if(is.numeric(variable)){\n    colpal <- paln(50)\n    colors <- colpal[cut(variable,breaks=50)]\n  }\n  \n  # draw the plot\n  plot(pca, bg = colors, pch = 21)\n  # draw lines\n  if(draw_lines){\n    lines(slingshot::SlingshotDataSet(sce), lwd = 2, ... )\n  }\n  # add legend\n  if(legend & is.factor(variable)){\n    legend(\"bottomright\", pt.bg = colpal,legend = levels(variable),pch=21)\n    \n  }\n}\n```\n:::\n\n\n\n\nHave a look at the PCA with the slingshot pseudotime line:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCAplot_slingshot(sce, variable = sce$slingPseudotime_1, draw_lines = TRUE)\n```\n:::\n\n\n\n\nAlso have a look at pseudotime versus cell type:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(as.data.frame(colData(deng_SCE)), aes(x = sce$slingPseudotime_1,\n                                             y = cell_type2,\n                                             colour = cell_type2)) +\n  ggbeeswarm::geom_quasirandom(groupOnX = FALSE) +\n  theme_classic() +\n  xlab(\"Slingshot pseudotime\") + ylab(\"Timepoint\") +\n  ggtitle(\"Cells ordered by Slingshot pseudotime\")\n```\n:::\n\n\n\n\nThis already looks pretty good. Let's see whether we can improve it. First we generate clusters by using `Seurat`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngcdata <- Seurat::CreateSeuratObject(counts = SingleCellExperiment::counts(deng_SCE),\n                                     project = \"slingshot\")\n\ngcdata <- Seurat::NormalizeData(object = gcdata,\n                                normalization.method = \"LogNormalize\",\n                                scale.factor = 10000)\n\ngcdata <- Seurat::FindVariableFeatures(object = gcdata,\n                                       mean.function = ExpMean,\n                                       dispersion.function = LogVMR)\n\ngcdata <- Seurat::ScaleData(object = gcdata,\n                            do.center = T,\n                            do.scale = F)\n\ngcdata <- Seurat::RunPCA(object = gcdata,\n                         pc.genes = gcdata@var.genes)\n\ngcdata <- Seurat::FindNeighbors(gcdata,\n                                reduction = \"pca\",\n                                dims = 1:5)\n\n# clustering with resolution of 0.6\ngcdata <- Seurat::FindClusters(object = gcdata,\n                               resolution = 0.6)\n```\n:::\n\n\n\n\nNow we can add these clusters to the `slingshot` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeng_SCE$Seurat_clusters <- as.character(Idents(gcdata))  # go from factor to character\n\nsce <- slingshot::slingshot(deng_SCE,\n                            clusterLabels = 'Seurat_clusters',\n                            reducedDim = 'PCA',\n                            start.clus = \"2\")\n```\n:::\n\n\n\n\nCheck how the slingshot object has evolved\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSlingshotDataSet(sce)\n```\n:::\n\n\n\n\nPlot PC1 versus PC2 colored by slingshot pseudotime:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCAplot_slingshot(sce, variable = sce$slingPseudotime_2)\n```\n:::\n\n\n\n\nPlot Slingshot pseudotime vs cell stage.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data.frame(cell_type2 = deng_SCE$cell_type2,\n                  slingPseudotime_1 = sce$slingPseudotime_1),\n       aes(x = slingPseudotime_1, y = cell_type2,\n           colour = cell_type2)) +\n  ggbeeswarm::geom_quasirandom(groupOnX = FALSE) +\n  theme_classic() +\n  xlab(\"Slingshot pseudotime\") + ylab(\"Timepoint\") +\n  ggtitle(\"Cells ordered by Slingshot pseudotime\")\n\nggplot(data.frame(cell_type2 = deng_SCE$cell_type2,\n                  slingPseudotime_2 = sce$slingPseudotime_2),\n       aes(x = slingPseudotime_2, y = cell_type2,\n           colour = cell_type2)) +\n  ggbeeswarm::geom_quasirandom(groupOnX = FALSE) +\n  theme_classic() +\n  xlab(\"Slingshot pseudotime\") + ylab(\"Timepoint\") +\n  ggtitle(\"Cells ordered by Slingshot pseudotime\")\n```\n:::\n\n\n\n\nParticularly the later stages, separation seems to improve. Since we have included the Seurat clustering, we can plot the PCA, with colors according to these clusters:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCAplot_slingshot(sce,\n                  variable = deng_SCE$Seurat_clusters,\n                  type = 'lineages',\n                  col = 'black',\n                  legend = TRUE)\n\nPCAplot_slingshot(sce,\n                  variable = deng_SCE$cell_type2,\n                  type = 'lineages',\n                  col = 'black',\n                  legend = TRUE)\n```\n:::\n\n\n\n\n::: {.callout-important}\n## Exercise\nInstead of providing an initial cluster, think of an end cluster that would fit this trajectory analysis and perform the slingshot analysis. Does slingshot find the initial cluster corresponding to the biological correct situation?\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- slingshot::slingshot(deng_SCE,\n                            clusterLabels = 'Seurat_clusters',\n                            reducedDim = 'PCA',\n                            end.clus = c(\"0\", \"3\", \"5\")) ## check which would be the best according to bio\n```\n:::\n\n\n\n:::\n\nClear your environment:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list = ls())\ngc()\n.rs.restartR()\n```\n:::\n\n\n\n\n### Trajectory analysis with `monocle3`\n\nThis part showcases how you can use `monocle3` to perform a trajectory analysis. First load the `seu` dataset:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu <- readRDS(\"seu_day2-4.rds\")\n```\n:::\n\n\n\n\nLoad the required package into your environment:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(monocle3)\n```\n:::\n\n\n\n\nGenerate a `monocle3` object (with class `cell_data_set`) from our `Seurat` object:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create gene metadata data.frame\nfeature_names <- as.data.frame(rownames(seu))\nrownames(feature_names) <- rownames(seu)\ncolnames(feature_names) <- \"gene_short_name\"\n\n# initiate monocle object from seurat count table \nseu_monocl <- monocle3::new_cell_data_set(Seurat::GetAssayData(seu,\n                                                               layer = \"counts\"),\n                                          cell_metadata = seu@meta.data,\n                                          gene_metadata = feature_names)\n```\n:::\n\n\n\n\nWe pre-process the newly created object. What does it involve? Check:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?preprocess_cds\n```\n:::\n\n\n\n\nPreprocess the dataset:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu_monocl <- monocle3::preprocess_cds(seu_monocl)\n```\n:::\n\n\n\n\nAnd check out the elbow plot:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonocle3::plot_pc_variance_explained(seu_monocl)\n```\n:::\n\n\n\n\nPerform UMAP using the implementation in the `monocle3` package and its default parameters:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu_monocl <- monocle3::reduce_dimension(seu_monocl, reduction_method = \"UMAP\")\n```\n:::\n\n\n\n\nPlot the `monocle3` UMAP coloring cells according to the cluster ID, marker gene or annotation that were stored in the `Seurat` object:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonocle3::plot_cells(seu_monocl, \n                     color_cells_by = \"RNA_snn_res.0.3\", \n                     cell_size = 1, \n                     show_trajectory_graph = FALSE)\n\nmonocle3::plot_cells(seu_monocl, genes = \"CD79A\", \n                     cell_size = 1,\n                     show_trajectory_graph = FALSE,\n                     scale_to_range = FALSE)\n\nmonocle3::plot_cells(seu_monocl, \n                     color_cells_by = \"SingleR_annot\", \n                     cell_size = 1, \n                     show_trajectory_graph = FALSE)\n```\n:::\n\n\n\n\nCluster cells using `monocle3`'s clustering function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu_monocl <- monocle3::cluster_cells(seu_monocl, resolution=0.00025)\nmonocle3::plot_cells(seu_monocl, label_cell_groups = F)\n```\n:::\n\n\n\n\nlearn graph (i.e. identify trajectory) using `monocle3` UMAP and clustering:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu_monocl <- monocle3::learn_graph(seu_monocl)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmonocle3::plot_cells(seu_monocl)\n```\n:::\n\n\n\n\n::: {.callout-important}\n## Exercise\nFind the CD34+ B-cell cluster in the monocle UMAP. This cluster has a high expressession of CD79A and expresses CD34.\n::: \n\n::: {.callout-tip collapse=\"true\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonocle3::plot_cells(seu_monocl, genes = c(\"CD79A\", \"CD34\"),\n                     show_trajectory_graph = FALSE, \n                     cell_size = 0.7, group_label_size = 4)\n```\n:::\n\n\n\n\nCluster 11 has both a high expression of CD79A and CD34. \n\n:::\n\nSelect the \"initial\" cells in the B-cell cluster to calculate pseudotime. The initial cells in this case are the CD34+ B-cells we have just identified. A pop up window will open and you need to click on the \"initial\" cells (one node per trajectory), then click \"Done\".\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu_monocl <- monocle3::order_cells(seu_monocl)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmonocle3::plot_cells(seu_monocl,\n                     color_cells_by = \"pseudotime\",\n                     label_cell_groups=F,\n                     label_leaves=F,\n                     label_branch_points=FALSE,\n                     graph_label_size=1.5, cell_size = 1)\n```\n:::\n\n\n\n\nIn order to find genes which expression is affected by pseudtime, we first have to isolate the B-cell cluster. Therefore, extract all cells in the B-cell cluster with the interactive `choose_cells` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseuB <- choose_cells(seu_monocl)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n<figure>\n<img src=\"../assets/images/choose_cells.gif\" width=\"500\"/>\n</figure>\n\n\nCheck whether you have selected the right cells:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_cells(seuB, show_trajectory_graph = FALSE, cell_size = 1,\n           color_cells_by = \"pseudotime\")\n```\n:::\n\n\n\n\nNow we can use the cells in this trajectory to test which genes are affected by the trajectory:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npr_test <- graph_test(seuB, \n                      cores=4, \n                      neighbor_graph = \"principal_graph\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# order by test statistic\npr_test <- pr_test[order(pr_test$morans_test_statistic, \n                         decreasing = TRUE),]\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nView(pr_test)\n```\n:::\n\n\n\n\nThere are some interesting genes in there, for example related to cell cycling (MKI67, CKS2), related to B-cell development (CD34, MS4A1) and immunoglobulins (IGLL1 and IGLL5). We can plot those in the UMAP:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngoi <- c(\"CD34\", \"MS4A1\", \"IGLL1\", \"IGLL5\", \n         \"MKI67\", \"CKS2\")\nplot_cells(seuB, label_cell_groups=FALSE, genes = goi,\n           show_trajectory_graph=FALSE, cell_size = 1)\n```\n:::\n\n\n\n\nBut also against pseudotime:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseuB@colData$monocle_cluster <- clusters(seuB)\n\nplot_genes_in_pseudotime(subset(seuB, \n                                rowData(seuB)$gene_short_name %in% goi),\n                         min_expr=0.5, color_cells_by = \"monocle_cluster\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}