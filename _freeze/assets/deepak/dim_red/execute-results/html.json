{
  "hash": "61004170e15a8cec29014da9f9ca6c82",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"PCA Analysis of Simulated scRNA-seq Data\"\neditor: source\nexecute:\n  eval: false\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load necessary libraries\nlibrary(ggplot2)\nlibrary(factoextra)\nlibrary(tidyverse)\nlibrary(splatter)  # For simulating scRNA-seq data\nlibrary(scran)     # For quality control and normalization (optional)\n\n# Set seed for reproducibility\nset.seed(123)\n\n# 1. Simulate scRNA-seq data with Splatter\n# Parameters for simulation\nn_genes <- 100    # Number of genes (features)\nn_cells <- 500     # Number of cells (samples)\nn_groups <- 10      # Number of cell groups (e.g., cell types)\nde_prob <- 0.7     # Probability of differential expression\nde_down_prob <- 0.2  # Probability of downregulation\nde_fac_loc <- 2    # Location parameter for differential expression factor\nde_fac_scale <- 0.5  # Scale parameter for differential expression factor\n\n# Simulate the data\nsim <- splatSimulate(group.prob = rep(1/n_groups, n_groups),\n                     nGenes = n_genes,\n                     batchCells = n_cells,  # Use batchCells instead of nCells\n                     de.prob = de_prob,\n                     de.downProb = de_down_prob,\n                     de.facLoc = de_fac_loc,\n                     de.facScale = de_fac_scale,\n                     method = \"groups\",\n                     verbose = FALSE)\n\n# Extract the count matrix\ncounts <- assays(sim)$counts\ndata_df <- t(counts)  # Transpose to have cells as rows and genes as columns\n\n# Optional: Normalize the data (e.g., using scran for scRNA-seq)\nlibrary_size <- colSums(counts)\nsize_factors <- calculateSumFactors(counts)\nnormalized_counts <- t(t(counts) / size_factors)\ndata_df <- as.data.frame(normalized_counts)\n\n# 1. Plot data variability (Boxplot of gene expression across cells)\nplot1 <- ggplot(data = log1p(data_df) %>% gather(key = \"Gene\", value = \"Expression\"),\n               aes(x = Gene, y = Expression)) +\n  geom_boxplot(fill = \"lightblue\", outlier.alpha = 0.1) +\n  theme_minimal() +\n  labs(title = \"Gene Expression Variability Across Cells\",\n       x = \"Genes\",\n       y = \"Normalized Expression\") +\n  theme(axis.text.x = element_blank())  # Too many genes to label\n\nprint(plot1)\n# ggsave(\"expression_variability_plot.png\", plot1, width = 8, height = 6)\n\n# 2. Perform PCA\n# Scale the data (important for PCA with scRNA-seq data)\npca_result <- prcomp(data_df, center = TRUE, scale. = TRUE)\n\n# Get PCA scores\npca_scores <- as.data.frame(pca_result$x)\n\n# 2. Plot first two principal components\nplot2 <- ggplot(pca_scores, aes(x = PC1, y = PC2)) +\n  geom_point(color = \"blue\", alpha = 0.6) +\n  theme_minimal() +\n  labs(title = \"PCA of Simulated scRNA-seq Data\",\n       x = paste0(\"PC1 (\", round(summary(pca_result)$importance[2,1]*100, 1), \"% variance)\"),\n       y = paste0(\"PC2 (\", round(summary(pca_result)$importance[2,2]*100, 1), \"% variance)\"))\n\nprint(plot2)\n# ggsave(\"pca_plot.png\", plot2, width = 8, height = 6)\n\n# INTERMEDIATE PLOT 2: PCA Directions (Loadings) on Original Data\n# Select two genes with high variance for illustration\nvar_genes <- apply(data_df, 2, var)\ntop_genes <- names(sort(var_genes, decreasing = TRUE)[1:2])\nplot_data <- data_df[, top_genes]\nloadings <- pca_result$rotation[, 1:2]  # Loadings for PC1 and PC2\n\n# Scale the loadings for visualization\nloadings_scaled <- loadings * 10  # Adjust scaling factor for visibility\n\n# Create a data frame for plotting the loadings as arrows\nloadings_df <- data.frame(\n  Gene = rownames(loadings),\n  PC1 = loadings_scaled[, \"PC1\"],\n  PC2 = loadings_scaled[, \"PC2\"]\n)\n\n# Scatterplot of original data with PCA directions overlaid\nplot_intermediate2 <- ggplot(plot_data, aes_string(x = top_genes[1], y = top_genes[2])) +\n  geom_point(color = \"blue\", alpha = 0.6) +\n  geom_segment(data = loadings_df, \n               aes(x = 0, y = 0, xend = PC1, yend = PC2), \n               arrow = arrow(length = unit(0.2, \"cm\")), \n               color = \"red\", size = 1) +\n  geom_text(data = loadings_df, \n            aes(x = PC1, y = PC2, label = Gene), \n            color = \"red\", vjust = -1, size = 3) +\n  theme_minimal() +\n  labs(title = \"Original Data with PCA Directions (PC1 and PC2 Loadings)\",\n       x = top_genes[1],\n       y = top_genes[2])\n\nprint(plot_intermediate2)\n# ggsave(\"pca_directions_plot.png\", plot_intermediate2, width = 8, height = 6)\n\n# INTERMEDIATE PLOT 3: Biplot (Feature Contributions to PCs)\nplot_intermediate3 <- fviz_pca_biplot(pca_result, \n                                     repel = TRUE,  # Avoid text overlap\n                                     col.var = \"red\",  # Color for variable arrows\n                                     col.ind = \"blue\",  # Color for individuals\n                                     alpha.ind = 0.6) +\n  theme_minimal() +\n  labs(title = \"PCA Biplot: Gene Contributions to PCs\")\n\nprint(plot_intermediate3)\n# ggsave(\"pca_biplot.png\", plot_intermediate3, width = 8, height = 6)\n\n# NEW PLOT: Orthogonal Vector Plot for PC1 and PC2\nscale_factor <- max(abs(pca_scores[, c(\"PC1\", \"PC2\")])) * 0.5  # Adjust scaling for visibility\northogonal_df <- data.frame(\n  PC = c(\"PC1\", \"PC2\"),\n  x_start = c(0, 0),\n  y_start = c(0, 0),\n  x_end = c(scale_factor, 0),\n  y_end = c(0, scale_factor)\n)\n\nplot_orthogonal <- ggplot(pca_scores, aes(x = PC1, y = PC2)) +\n  geom_point(color = \"blue\", alpha = 0.6) +\n  geom_segment(data = orthogonal_df, \n               aes(x = x_start, y = y_start, xend = x_end, yend = y_end), \n               arrow = arrow(length = unit(0.2, \"cm\")), \n               color = \"red\", size = 1) +\n  geom_text(data = orthogonal_df, \n            aes(x = x_end, y = y_end, label = PC), \n            color = \"red\", vjust = -1, hjust = ifelse(orthogonal_df$PC == \"PC1\", 0.5, -0.1)) +\n  theme_minimal() +\n  labs(title = \"Orthogonal Directions of PC1 and PC2\",\n       x = paste0(\"PC1 (\", round(summary(pca_result)$importance[2,1]*100, 1), \"% variance)\"),\n       y = paste0(\"PC2 (\", round(summary(pca_result)$importance[2,2]*100, 1), \"% variance)\")) +\n  coord_equal()\n\nprint(plot_orthogonal)\n# ggsave(\"orthogonal_vector_plot.png\", plot_orthogonal, width = 8, height = 6)\n\n# 3. Create Elbow plot\nvar_explained <- summary(pca_result)$importance[2,]\ncum_var_explained <- summary(pca_result)$importance[3,]\n\nelbow_df <- data.frame(\n  PC = 1:ncol(data_df),\n  Standard_Deviation = sqrt(var_explained) * 100  # Convert variance to standard deviation\n)\n\nplot3 <- ggplot(elbow_df, aes(x = PC, y = Standard_Deviation)) +\n  geom_line(color = \"black\") +\n  geom_point(color = \"black\") +\n  theme_minimal() +\n  labs(title = \"Elbow Plot for PCA (Standard Deviation)\",\n       x = \"Principal Component\",\n       y = \"Standard Deviation\") +\n  scale_x_continuous(breaks = seq(1, ncol(data_df), by = 5)) +\n  ylim(0, max(elbow_df$Standard_Deviation) * 1.1)  # Set y-limit to match your example\n\nprint(plot3)\n# ggsave(\"elbow_plot.png\", plot3, width = 8, height = 6)\n\n# Print summary of PCA to help decide number of components\nprint(summary(pca_result))\n\n# Optional: Use factoextra to create a nicer scree plot\nplot4 <- fviz_eig(pca_result, addlabels = TRUE, ylim = c(0, max(elbow_df$Standard_Deviation) * 1.1))\nprint(plot4)\n# ggsave(\"scree_plot.png\", plot4, width = 8, height = 6)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}