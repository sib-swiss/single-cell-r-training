{
  "hash": "eca12ba349536c0171cb5cdaff3853c3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Clustering\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n\n\n\n## Material\n\n\n\n\n\n{{< downloadthis ../assets/pdf/202503_clustering.pdf dname=\"Clustering_SIB\" label=\"Download the presentation\" icon=\"filetype-pdf\" >}}\n\n\n{{< video https://youtu.be/kqcvqqZp3Jo?si=T1lHw0z-4wv6BvF- >}}\n\n\n{{< downloadthis ../assets/pdf/scRNAseq_clustering_RM.pdf dname=\"scRNAseq_clustering_RM\" label=\"Download the presentation from the video\" icon=\"filetype-pdf\" >}}\n\n\n\n\n\n\n\n\n\n\n- Evaluation of [clustering methods](https://f1000research.com/articles/7-1141)\n\n## Exercises\n\nLoad the `seu` dataset you have created earlier today:\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\nThe method implemented in Seurat first constructs a SNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the `FindNeighbors()` function, and takes as input the previously defined dimensionality of the dataset.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu <- Seurat::FindNeighbors(seu, dims = 1:25, reduction = \"integrated.cca\")\n```\n:::\n\n\n\n\n\nTo cluster the cells, Seurat next implements modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function. The `FindClusters()` function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu <- Seurat::FindClusters(seu, resolution = seq(0.1, 0.8, by=0.1))\n```\n:::\n\n\n\n\n\nCluster id of each cell is added to the metadata object, as a new column for each resolution tested:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(seu@meta.data)\n```\n:::\n\n\n\n\n\nTo view how clusters sub-divide at increasing resolution:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(clustree)\nclustree::clustree(seu@meta.data[,grep(\"RNA_snn_res\", colnames(seu@meta.data))],\n                   prefix = \"RNA_snn_res.\")\n```\n:::\n\n\n\n\n\nYou can view the UMAP coloring each cell according to a cluster id like this:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSeurat::DimPlot(seu, group.by = \"RNA_snn_res.0.1\")\n```\n:::\n\n\n\n\n\n::: {.callout-important}\n## Exercise\nVisualise clustering based on a few more resolutions. Taking the clustering and the UMAP plots into account what do you consider as a good resolution to perform the clustering?\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\nOf course, there is no 'optimal' resolution, but based on resolution of 0.3, the tree stays relatively stable for a few resolution steps, and it seems that clustering fits the UMAP well:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSeurat::DimPlot(seu, group.by = \"RNA_snn_res.0.3\")\n```\n:::\n\n\n\n\n:::\n\n::: {.callout-important}\n## Exercise\nWhen do the number of neighbors need to be changed? How does changing the method of clustering in `FindClusters` affect the output? Which parameter should be changed?\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\nAs FindClusters is an unsupervised clustering method on the PCA data and UMAP is a good summary of the PCA dimension selected, clusters and UMAP plot should go along. If one has reasons to change the number of neighbors in the UMAP function, here the same parameter should be adapted.\n    \nThe method can be changed with algorithm = 2,3 or 4\n:::\n\n\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}